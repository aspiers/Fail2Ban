#! /bin/sh /usr/share/dpatch/dpatch-run
## 00_full_line_failregex.dpatch by Yaroslav Halchenko <debian@onerussian.com>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad full_line_failregex~/config/filter.d/common.conf full_line_failregex/config/filter.d/common.conf
--- full_line_failregex~/config/filter.d/common.conf	1969-12-31 19:00:00.000000000 -0500
+++ full_line_failregex/config/filter.d/common.conf	2007-08-20 14:54:24.000000000 -0400
@@ -0,0 +1,41 @@
+# Generic configuration items (to be used as interpolations) in other
+# filters  or actions configurations
+#
+# Author: Yaroslav Halchenko
+#
+# $Revision:  $
+#
+
+[INCLUDES]
+
+# Load customizations if any available
+files_after = %(configpath)s/filter.d/common.local
+
+
+[DEFAULT]
+
+# Daemon definition is to be specialized (if needed) in .conf file
+_daemon = \S*
+
+#
+# Shortcuts for easier comprehension of the failregex
+#
+# PID.
+# EXAMPLES: [123]
+__pid_re = (?:\[\d+\])
+
+# Daemon name (with optional source_file:line or whatever)
+# EXAMPLES: pam_rhosts_auth, [sshd], pop(pam_unix)
+__daemon_re = [\[\(]?%(_daemon)s(?:\(\S+\))?[\]\)]?:?
+
+# Combinations of daemon name and PID
+# EXAMPLES: sshd[31607], pop(pam_unix)[4920]
+__daemon_combs_re = (?:%(__pid_re)s?:\s+%(__daemon_re)s|%(__daemon_re)s%(__pid_re)s?:)
+
+#
+# Common line prefixes (beginnings) which could be used in filters
+#
+#       [hostname] [vserver tag] daemon_id spaces
+# this can be optional (for instance if we match named native log files)
+__prefix_line = \s*(?:\S+ )?(?:@vserver_\S+ )?%(__daemon_combs_re)s?\s*
+
diff -urNad full_line_failregex~/server/filter.py full_line_failregex/server/filter.py
--- full_line_failregex~/server/filter.py	2007-08-20 14:52:38.000000000 -0400
+++ full_line_failregex/server/filter.py	2007-08-20 14:54:04.000000000 -0400
@@ -383,7 +383,7 @@
 			logSys.error("Unable to get failures in " + filename)
 			return False
 		self.__setFilePos()
-		lastLine = None
+		lastTimeLine = None
 		for line in self.__crtHandler:
 			if not self._isActive():
 				# The jail has been stopped
@@ -393,11 +393,18 @@
 				line = line.decode('utf-8')
 			except UnicodeDecodeError:
 				pass
-			if not self.dateDetector.matchTime(line):
+			timeMatch = self.dateDetector.matchTime(line)
+			if not matchTime:
 				# There is no valid time in this line
 				continue
-			lastLine = line
-			for element in self.findFailure(line):
+			# Lets split into time part and log part of the line
+			timeLine = timeMatch.group()
+			# Lets leave the beginning in as well, so if there is no
+			# anchore at the beginning of the time regexp, we don't
+			# at least allow injection. Should be harmless otherwise
+			logLine  = line[:timeMatch.start()] + line[timeMatch.end():]
+			lastTimeLine = timeLine
+			for element in self.findFailure(timeLine, logLine):
 				ip = element[0]
 				unixTime = element[1]
 				if unixTime < MyTime.time()-self.__findTime:
@@ -408,8 +415,8 @@
 				logSys.debug("Found "+ip)
 				self.failManager.addFailure(FailTicket(ip, unixTime))
 		self.__lastPos[filename] = self.__getFilePos()
-		if lastLine:
-			self.__lastDate[filename] = self.dateDetector.getUnixTime(lastLine)
+		if lastTimeLine:
+			self.__lastDate[filename] = self.dateDetector.getUnixTime(lastTimeLine)
 		self.__closeLogFile()
 		return True
 
@@ -428,27 +435,28 @@
 		return False
 
 	##
-	# Finds the failure in a line.
+	# Finds the failure in a line given split into time and log parts.
 	#
 	# Uses the failregex pattern to find it and timeregex in order
 	# to find the logging time.
 	# @return a dict with IP and timestamp.
 
-	def findFailure(self, line):
+	def findFailure(self, timeLine, logLine):
 		failList = list()
 		# Checks if we must ignore this line.
-		if self.ignoreLine(line):
+		if self.ignoreLine(logLine):
 			# The ignoreregex matched. Return.
 			return failList
 		# Iterates over all the regular expressions.
 		for failRegex in self.__failRegex:
-			failRegex.search(line)
+			failRegex.search(logLine)
 			if failRegex.hasMatched():
 				# The failregex matched.
-				date = self.dateDetector.getUnixTime(line)
+				date = self.dateDetector.getUnixTime(timeLine)
 				if date == None:
-					logSys.debug("Found a match but no valid date/time found "
-								 + "for " + line + ". Please contact the "
+					logSys.debug("Found a match for '" + logLine +"' but no "
+								 + "valid date/time found for '"
+								 + timeLine + "'. Please contact the "
 								 + "author in order to get support for this "
 								 + "format")
 				else:
